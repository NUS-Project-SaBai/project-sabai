# Drizzle ORM Documentation

This document explains how Drizzle ORM is configured to work with Supabase Postgres in this project.

## Table of Contents

1. [Overview](#1-overview)
2. [Project Structure](#2-project-structure)
3. [Environment Setup](#3-environment-setup)
4. [Schema Definition](#4-schema-definition)
5. [Database Client](#5-database-client)
6. [Migrations](#6-migrations)
7. [Query Patterns](#7-query-patterns)
8. [tRPC Integration](#8-trpc-integration)
9. [Type Safety](#9-type-safety)
10. [Troubleshooting](#10-troubleshooting)

---

## 1. Overview

### What is Drizzle?

Drizzle is a TypeScript-first ORM that:
- Generates SQL from TypeScript schema definitions
- Provides full type safety for queries
- Has zero runtime overhead (compiles to plain SQL)
- Works seamlessly with Postgres (and Supabase)

### Why Drizzle over Prisma?

| Feature | Drizzle | Prisma |
|---------|---------|--------|
| Bundle size | ~50KB | ~2MB |
| Type inference | From schema | Generated client |
| SQL control | Full (SQL-first) | Abstracted |
| Migrations | SQL files | Prisma format |
| Learning curve | SQL knowledge helps | ORM-specific syntax |

### Tech Stack

| Component | Technology |
|-----------|------------|
| ORM | Drizzle ORM |
| Database | Supabase Postgres |
| Driver | `postgres` (postgres.js) |
| Migration Tool | Drizzle Kit |

---

## 2. Project Structure

```
project-sabai/
├── drizzle.config.ts          # Drizzle Kit configuration
├── src/
│   └── db/
│       ├── drizzle.ts         # Database client instance
│       └── schema.ts          # Table definitions & types
└── supabase/
    └── migrations/            # Generated SQL migration files
        ├── 0000_xxx.sql
        ├── 0001_xxx.sql
        └── meta/
            └── _journal.json  # Migration history
```

### File Purposes

| File | Purpose |
|------|---------|
| `drizzle.config.ts` | Tells Drizzle Kit where to find schemas and output migrations |
| `src/db/schema.ts` | Defines tables, columns, relations, and exports types |
| `src/db/drizzle.ts` | Creates and exports the `db` client instance |
| `supabase/migrations/` | SQL files generated by `drizzle-kit generate` |

---

## 3. Local Environment Setup

### Required Environment Variables

Populate `.env` with the values from your **local** Supabase instance.
Running `supabase status` will output the DB URL.

```bash
supabase status
```

Add to `.env` for local development:

```bash
#for example
DATABASE_URL=postgresql://postgres:postgres@127.0.0.1:54322/postgres
```

---

## 4. Schema Definition

### Basic Table Definition

```typescript
// src/db/schema.ts
import { pgTable, serial, varchar, boolean, timestamp } from "drizzle-orm/pg-core";

export const villageCodes = pgTable("village_codes", {
  // Auto-incrementing primary key
  id: serial("id").primaryKey(),
  
  // Strings with constraints
  code: varchar("code", { length: 255 }).notNull().unique(),
  name: varchar("name", { length: 255 }).notNull(),
  
  // Fixed-length string for hex colors
  colorHex: varchar("color_hex", { length: 7 }).notNull(),
  
  // Boolean with default
  isVisible: boolean("is_visible").default(true).notNull(),
  
  // Timestamps
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull().$onUpdate(() => new Date()),
});
```

### Column Naming Convention

Drizzle maps **camelCase** TypeScript names to **snake_case** database columns:

```typescript
// TypeScript property → Database column
colorHex: varchar("color_hex", ...)  // colorHex → color_hex
isVisible: boolean("is_visible", ...) // isVisible → is_visible
createdAt: timestamp("created_at", ...) // createdAt → created_at
```

### Common Column Types

```typescript
import {
  pgTable,
  serial,        // Auto-increment integer
  integer,       // Regular integer
  bigint,        // Big integer
  varchar,       // Variable-length string
  text,          // Unlimited text
  boolean,       // true/false
  timestamp,     // Date + time
  date,          // Date only
  json,          // JSON data
  jsonb,         // Binary JSON (faster queries)
  uuid,          // UUID type
  decimal,       // Precise decimal
  real,          // Floating point
} from "drizzle-orm/pg-core";
```

### Adding Indexes

```typescript
import { pgTable, varchar, index } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: varchar("email", { length: 255 }).notNull(),
  organizationId: integer("organization_id"),
}, (table) => ({
  // Single-column index
  emailIdx: index("email_idx").on(table.email),
  
  // Composite index
  orgEmailIdx: index("org_email_idx").on(table.organizationId, table.email),
}));
```

### Defining Relations

```typescript
// src/db/schema.ts
import { pgTable, serial, integer, varchar } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

// Parent table
export const organizations = pgTable("organizations", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
});

// Child table with foreign key
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  name: varchar("name", { length: 255 }).notNull(),
  organizationId: integer("organization_id").references(() => organizations.id),
});

// Define relations for query builder
export const organizationsRelations = relations(organizations, ({ many }) => ({
  users: many(users),
}));

export const usersRelations = relations(users, ({ one }) => ({
  organization: one(organizations, {
    fields: [users.organizationId],
    references: [organizations.id],
  }),
}));
```

### Exporting Types

Always export inferred types for use in your application:

```typescript
// src/db/schema.ts

// Infer SELECT type (what you get when querying)
export type VillageCode = typeof villageCodes.$inferSelect;
// { id: number; code: string; name: string; colorHex: string; isVisible: boolean; ... }

// Infer INSERT type (what you provide when inserting)
export type NewVillageCode = typeof villageCodes.$inferInsert;
// { code: string; name: string; colorHex: string; isVisible?: boolean; ... }
```

---

## 5. Database Client

### Client Setup

```typescript
// src/db/drizzle.ts
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import * as schema from "./schema";

const connectionString = process.env.DATABASE_URL!;

// Create postgres.js client
const client = postgres(connectionString);

// Create Drizzle instance with schema for relational queries
export const db = drizzle(client, { schema });
```

### Why Pass `schema` to `drizzle()`?

Passing the schema enables the **relational query API** (`db.query.*`):

```typescript
// With schema: Can use db.query.* (recommended)
const db = drizzle(client, { schema });
const users = await db.query.users.findMany();

// Without schema: Must use SQL-like syntax
const db = drizzle(client);
const users = await db.select().from(schema.users);
```

---

## 6. Migrations

### Drizzle Kit Configuration

```typescript
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  schema: "./src/db/schema.ts",        // Where your schema is defined
  out: "./supabase/migrations",        // Where to output SQL files
  dialect: "postgresql",               // Database type
  dbCredentials: {
    url: process.env.DATABASE_URL!,    // Connection string
  },
});
```

### Migration Commands

#### 1. Generate Migration (Schema → SQL)

When you change your schema, generate a new migration:

```bash
npx drizzle-kit generate
```

This creates a new SQL file in `supabase/migrations/`:

```sql
-- 0001_some_name.sql
CREATE TABLE "village_codes" (
  "id" serial PRIMARY KEY NOT NULL,
  "code" varchar(255) NOT NULL,
  ...
);
```

#### 2. Apply Migrations (SQL → Database)

Push the migrations to your database:

```bash
npx drizzle-kit migrate
```

#### 3. Push Without Migration Files (Development)

For rapid prototyping, push schema changes directly:

```bash
npx drizzle-kit push
```

> ⚠️ **Warning**: `push` doesn't create migration files. Use `generate` + `migrate` for production.

#### 4. View Current Schema

Open Drizzle Studio to browse your database:

```bash
npx drizzle-kit studio
```

### Migration Workflow

```
┌─────────────────────────────────────────────────────────────┐
│                    DEVELOPMENT WORKFLOW                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. Edit schema.ts                                          │
│        │                                                    │
│        ▼                                                    │
│  2. npx drizzle-kit generate                                │
│        │                                                    │
│        ▼                                                    │
│  3. Review generated SQL in supabase/migrations/            │
│        │                                                    │
│        ▼                                                    │
│  4. npx drizzle-kit migrate                                 │
│        │                                                    │
│        ▼                                                    │
│  5. Commit schema.ts + migration files                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### Example: Adding a New Column

**Step 1: Update schema**

```typescript
// src/db/schema.ts
export const villageCodes = pgTable("village_codes", {
  // ... existing columns
  description: text("description"), // NEW COLUMN
});
```

**Step 2: Generate migration**

```bash
npx drizzle-kit generate
```

**Step 3: Review the generated SQL**

```sql
-- supabase/migrations/0001_add_description.sql
ALTER TABLE "village_codes" ADD COLUMN "description" text;
```

**Step 4: Apply migration**

```bash
npx drizzle-kit migrate
```

---

## 7. Query Patterns

### Select Queries

#### Find Many (with filter)

```typescript
import { db } from "@/db/drizzle";
import { villageCodes } from "@/db/schema";
import { eq, desc } from "drizzle-orm";

// Using relational query API
const codes = await db.query.villageCodes.findMany({
  where: eq(villageCodes.isVisible, true),
  orderBy: [desc(villageCodes.createdAt)],
  limit: 10,
});

// Using SQL-like API (equivalent)
const codes = await db
  .select()
  .from(villageCodes)
  .where(eq(villageCodes.isVisible, true))
  .orderBy(desc(villageCodes.createdAt))
  .limit(10);
```

#### Find First (single record)

```typescript
const code = await db.query.villageCodes.findFirst({
  where: eq(villageCodes.id, 1),
});
// Returns: VillageCode | undefined
```

### Insert Queries

#### Insert One

```typescript
const [newCode] = await db
  .insert(villageCodes)
  .values({
    code: "V001",
    name: "Village One",
    colorHex: "#FF5733",
  })
  .returning(); // Returns the inserted row
```

#### Insert Many

```typescript
const newCodes = await db
  .insert(villageCodes)
  .values([
    { code: "V001", name: "Village One", colorHex: "#FF5733" },
    { code: "V002", name: "Village Two", colorHex: "#33FF57" },
  ])
  .returning();
```

### Update Queries

```typescript
const [updated] = await db
  .update(villageCodes)
  .set({
    name: "Updated Name",
    isVisible: false,
  })
  .where(eq(villageCodes.id, 1))
  .returning();
```

### Delete Queries

```typescript
const [deleted] = await db
  .delete(villageCodes)
  .where(eq(villageCodes.id, 1))
  .returning();
```

### Query Operators

```typescript
import {
  eq,        // Equal: WHERE id = 1
  ne,        // Not equal: WHERE id != 1
  gt,        // Greater than: WHERE id > 1
  gte,       // Greater or equal: WHERE id >= 1
  lt,        // Less than: WHERE id < 1
  lte,       // Less or equal: WHERE id <= 1
  like,      // Pattern match: WHERE name LIKE '%foo%'
  ilike,     // Case-insensitive like
  inArray,   // IN: WHERE id IN (1, 2, 3)
  notInArray,// NOT IN
  isNull,    // IS NULL
  isNotNull, // IS NOT NULL
  and,       // AND
  or,        // OR
  not,       // NOT
  between,   // BETWEEN
  desc,      // ORDER BY DESC
  asc,       // ORDER BY ASC
} from "drizzle-orm";
```

### Complex Where Clauses

```typescript
import { and, or, eq, gt, like } from "drizzle-orm";

const results = await db.query.villageCodes.findMany({
  where: and(
    eq(villageCodes.isVisible, true),
    or(
      like(villageCodes.name, "%Village%"),
      gt(villageCodes.id, 10)
    )
  ),
});
```

### Selecting Specific Columns

```typescript
const codes = await db
  .select({
    id: villageCodes.id,
    name: villageCodes.name,
  })
  .from(villageCodes);
// Returns: { id: number; name: string }[]
```

### Joins

```typescript
import { users, organizations } from "@/db/schema";

const results = await db
  .select({
    userName: users.name,
    orgName: organizations.name,
  })
  .from(users)
  .leftJoin(organizations, eq(users.organizationId, organizations.id));
```

### With Relations (Relational Query API)

```typescript
// Assuming relations are defined in schema
const usersWithOrg = await db.query.users.findMany({
  with: {
    organization: true, // Include related organization
  },
});
// Returns: { id, name, organization: { id, name } }[]
```

---

## 8. tRPC Integration

### Importing in Routers

```typescript
// src/server/routers/villageCodeRouters.ts
import { db } from "@/db/drizzle";
import { villageCodes } from "@/db/schema";
import { eq, desc } from "drizzle-orm";
```

### Full CRUD Example

```typescript
import { z } from "zod";
import { TRPCError } from "@trpc/server";
import { router, protectedProcedure } from "../trpc";
import { db } from "@/db/drizzle";
import { villageCodes } from "@/db/schema";
import { eq, desc } from "drizzle-orm";

export const villageCodeRouter = router({
  // LIST
  list: protectedProcedure
    .input(z.object({ includeHidden: z.boolean().default(false) }))
    .query(async ({ input }) => {
      return await db.query.villageCodes.findMany({
        where: input.includeHidden 
          ? undefined 
          : eq(villageCodes.isVisible, true),
        orderBy: [desc(villageCodes.createdAt)],
      });
    }),

  // GET BY ID
  getById: protectedProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ input }) => {
      const result = await db.query.villageCodes.findFirst({
        where: eq(villageCodes.id, input.id),
      });
      return result || null;
    }),

  // CREATE
  create: protectedProcedure
    .input(z.object({
      code: z.string().min(1),
      name: z.string().min(1),
      colorHex: z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/),
      isVisible: z.boolean().default(true),
    }))
    .mutation(async ({ input }) => {
      const [newCode] = await db
        .insert(villageCodes)
        .values(input)
        .returning();
      return newCode;
    }),

  // UPDATE
  update: protectedProcedure
    .input(z.object({
      id: z.number(),
      name: z.string().optional(),
      colorHex: z.string().regex(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/).optional(),
      isVisible: z.boolean().optional(),
    }))
    .mutation(async ({ input }) => {
      const { id, ...data } = input;
      
      const [updated] = await db
        .update(villageCodes)
        .set(data)
        .where(eq(villageCodes.id, id))
        .returning();

      if (!updated) {
        throw new TRPCError({ code: "NOT_FOUND" });
      }

      return updated;
    }),

  // DELETE
  delete: protectedProcedure
    .input(z.object({ id: z.number() }))
    .mutation(async ({ input }) => {
      const [deleted] = await db
        .delete(villageCodes)
        .where(eq(villageCodes.id, input.id))
        .returning();

      if (!deleted) {
        throw new TRPCError({ code: "NOT_FOUND" });
      }

      return deleted;
    }),
});
```

### Error Handling Pattern

```typescript
// Check if record exists before update/delete
const [updated] = await db
  .update(villageCodes)
  .set(data)
  .where(eq(villageCodes.id, id))
  .returning();

if (!updated) {
  throw new TRPCError({
    code: "NOT_FOUND",
    message: "Village code not found",
  });
}
```

---

## 9. Type Safety

### Schema-Inferred Types

```typescript
// src/db/schema.ts
export type VillageCode = typeof villageCodes.$inferSelect;
// {
//   id: number;
//   code: string;
//   name: string;
//   colorHex: string;
//   isVisible: boolean;
//   createdAt: Date;
//   updatedAt: Date;
// }

export type NewVillageCode = typeof villageCodes.$inferInsert;
// {
//   code: string;
//   name: string;
//   colorHex: string;
//   isVisible?: boolean;      // Optional (has default)
//   createdAt?: Date;         // Optional (has default)
//   updatedAt?: Date;         // Optional (has default)
// }
```

### Using Types in Components

```typescript
import type { VillageCode } from "@/db/schema";

function VillageCodeCard({ code }: { code: VillageCode }) {
  return (
    <div>
      <h3>{code.name}</h3>
      <span style={{ color: code.colorHex }}>{code.code}</span>
    </div>
  );
}
```

### Type-Safe Query Results

```typescript
// Result is automatically typed as VillageCode[]
const codes = await db.query.villageCodes.findMany();

// TypeScript knows the shape
codes.forEach(code => {
  console.log(code.name);      // ✅ OK
  console.log(code.nonExistent); // ❌ Type error
});
```

---

## 10. Troubleshooting

### Problem: "Connection terminated unexpectedly"

**Cause:** Using wrong port or connection string.

**Fix:** Ensure you're using the pooled connection (port 6543):

```bash
DATABASE_URL="postgresql://...@pooler.supabase.com:6543/postgres?pgbouncer=true"
```

### Problem: Migration fails with "prepared statement already exists"

**Cause:** PgBouncer doesn't support prepared statements in transaction mode.

**Fix:** Add `?pgbouncer=true&prepare=false` to your connection string:

```bash
DATABASE_URL="postgresql://...?pgbouncer=true&prepare=false"
```

### Problem: `db.query.tableName` is undefined

**Cause:** Schema not passed to `drizzle()`.

**Fix:** Ensure you pass the schema:

```typescript
import * as schema from "./schema";
export const db = drizzle(client, { schema }); // ✅
```

### Problem: Types not updating after schema change

**Fix:** Restart your TypeScript server:
- VS Code: `Cmd/Ctrl + Shift + P` → "TypeScript: Restart TS Server"

### Problem: "relation does not exist" error

**Cause:** Migration not applied.

**Fix:**
```bash
npx drizzle-kit migrate
```

Or for prototyping:
```bash
npx drizzle-kit push
```

### Problem: Slow queries

**Possible causes:**
1. Missing indexes
2. Fetching too much data
3. N+1 queries

**Fixes:**
```typescript
// Add indexes in schema
export const users = pgTable("users", {
  email: varchar("email"),
}, (table) => ({
  emailIdx: index("email_idx").on(table.email),
}));

// Limit results
const codes = await db.query.villageCodes.findMany({
  limit: 50,
});

// Use `with` for relations instead of separate queries
const usersWithOrgs = await db.query.users.findMany({
  with: { organization: true },
});
```

---

## Quick Reference

### Common Commands

| Command | Purpose |
|---------|---------|
| `npx drizzle-kit generate` | Generate migration from schema changes |
| `npx drizzle-kit migrate` | Apply pending migrations |
| `npx drizzle-kit push` | Push schema directly (dev only) |
| `npx drizzle-kit studio` | Open database GUI |
| `npx drizzle-kit drop` | Drop a migration |

### Import Cheatsheet

```typescript
// Client
import { db } from "@/db/drizzle";

// Schema & types
import { villageCodes, type VillageCode, type NewVillageCode } from "@/db/schema";

// Operators
import { eq, ne, gt, lt, and, or, like, desc, asc, inArray } from "drizzle-orm";
```

### Query Patterns Cheatsheet

```typescript
// Find many
await db.query.tableName.findMany({ where, orderBy, limit });

// Find one
await db.query.tableName.findFirst({ where });

// Insert
await db.insert(tableName).values(data).returning();

// Update
await db.update(tableName).set(data).where(condition).returning();

// Delete
await db.delete(tableName).where(condition).returning();
```
